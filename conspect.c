-c Compile or assemble the source files, but do not link
-S Stop after the stage of compilation proper; do not assemble. 

исходник > препроцессор (что-то делает с .h) > компилятор (преобразует именно в машинный код) > компоновщик (линкер, линковщик)
В асме сначала идёт исходник, он трансилруется ассемблером в объектный код, замет линкуется линкером. 


Директивы нужный для препроцессора, сообщают ему о необходимости включения заголовочного файла (stdio.h, например).
Заголовочный файл содержит много всячины, вроде Содержат много всего, в том числе - прототипы функций.
#include <stdio.h> printf(), scanf() 
#include <stdlib.h> system()
#include <math.h> 
#include <conio.h> getchar()
#include <time.h> time(NULL)
#include <unistd.h> sleep()

//define 
Умеют много чего, не путать с функцией, это именно символьные замены.
#include <stdio.h>
#define MASK(x) x&0xFF

int main(){
	printf("%d\n", MASK(4095) );
	//равносильно такому написанию:
	printf("%d\n", 4095&0xFF );
	return 0;
}
4095 0xFFF 0000 1111 1111 1111



main - главная функция (в win нужно указывать тип возвращаемых (void, int) ею данных). 
В случае, если функция возвращает ничего (void), указание возврата (return) можно не писать.
В main return 0 означает конец  программы.

int main(){
}
// ИЛИ
int main(){
	return 0;
}

// \n - ESC код, их много, работают с функцией printf.
int maim(){
	int integer1; // объявление имен переменных и их типа данных, а также можно и значение указать.
				  // имя до 31 символа, учитываются строчные и заглавные буквы.
				  // объявления должны располагаться после первой левой скобки и  п е р е д  п е р в ы м  исполняемым оператором.
	int integer2 = 123;
	scanf ("%d", &integer1) //%d - показывает, что данные должны быть целым числом
					//&d - знаком амперсанда задается операция взятия адреса следующей за ним переменной.
					//Сообщает сканфу ячейку памяти, в которой хранится переменная integer1. Компьютер будет хранить 
					//величину для integer1 в этой ячейке. Подробнее расмотрено в главе про указатели.
}
//Явные и неявные преобразования
int main(){
	int A = 5; 
	int B = 2;
	float C = 2;
	printf("%d\n", A/B ); // целое на целое отбросит дробную часть
	printf("%f\n", A/C) ; // выполнит неявное преобразование целого B в float (создаст копию)
	printf("%f\n", (float) A/B ); //выполнит явное преобразование A в float, B тогда возведётся до float
}
Ибо первое преобразование int даст 1.
3/2*3.14=3.14 

// if
int main(){	
	int A;
	scanf ("%d", &A);
	
	if (A >= 2){
		printf(">=2\n");
	}

	if (A < 2){
		printf("<2\n");
	}

}

if (/* condition */)
	printf("AAA");
else
	if (/* condition */)
		printf("BBB");
	else
		if ()
			printf("CCC");

if (/* condition */)
	printf("AAA");
else if (/* condition */)
	printf("BBB");
else if (/* condition */)
	printf("CCC");

//дополнение
printf("%s\n", grade >= 60 ? "Passed" : "Failed" );

grade >= 60 ? printf("Passed") : printf("Failed" );

//while
 while (stud < 10){
 	printf("AAA");
 	stud = stud + 1;
 }

//операции присваивания
c = c + 3;
равносильно
c += 3; - но так быстрее.
	
++a; // преинкремент, увеличивает на 1, использует новое значение.
a++; // постинкремент, использует значение, потом увеличивает на 1.  
a += 1 равносильно a = a + 1

a = 5;
printf("%d\n", ++a );
printf("%d\n", a);
a = 5;
printf("%d\n", a++);
printf("%d\n", a);

даст:
6
6
5
6

//
int counter = 0;
while (++counter <= 2)
	printf("%d\n", counter);
1
2

int counter = 0;
while (counter++ <= 2)
	printf("%d\n", counter);
1
2
3

// for

int main(){
	
	for (int i = 0; i <= 2; i++){

		printf("%d\n", i );
	}
	return 0;
}

//switch
int main(){

	int gon = 0;
	
	while ( gon != -1 ) {
		scanf ("%d", &gon);
		switch (gon) {
			case 1 : case 2 : // если gon = 1 или gon = 2
				printf("1or2");
				break;

			case 5 : // если равен 5
				printf("5");
				break;

			case '\n' : case '': // игнор символа переноса и пробела, если работа с символами
				break;

			default : // все остальные случаи
				printf("other");
				break;
		}			
	}
	return 0;
}	

// do while
int main(){
	int counter = 1;
	do {
		printf("%d\n", counter);
	}	while ( ++counter <= 10);
	return 0;
}


// break continue

int main(){
	int  x;

	for (x = 1; x <= 10; x++){
		if(x == 5)
			break; // break досрочно выводит из цикла, есть и другие структурные способы это сделать.
		printf("%d ", x );
	}

	printf("lalala %d\n", x);
	return 0;
}

int main(){
	int  x;

	for (x = 1; x <= 10; x++){
		if(x == 5)
			continue; // continue пропускает оставшийся код в цикле, если х == 5.
		printf("%d ", x );
	}

	printf("lalala %d\n", x);
	return 0;
}

//логические
int main(){
	int  x;

	scanf("%d", &x);

	if ( !(x == 2) )	{
		printf("!(%d==2)\n", x);
	}		
	return 0;
}


//функции
Любая функция должна быть объявлена перед тем, как будет использована. Просто надо, иначе будут ошибки. Хоть и есть нюансы. Стр180 Дейтла.
Прототип соответствует списку параметров. Если прототип не указать - компилятор сам создаст кое-как прототип и будет бида.
Имена лучше делать разными. 
Если не указать тип возвращаемых - то по-умолчанию будет int.
Если не указать тип принимаемых - то ????? скорее всего будет void, может быть тогда может принимать любое количество параметров...
	Короче, лучше конкретно указывать void. А вот в main это непринципиально, похоже.

тип возвращаемых ИМЯ (тип принимаемых значений по порядку, оно же список параметров)

float FUNC(int, double); //прототип

float FUNC(int x, double y) { //тело функции
}

//1
float FUNC(int);
	
int main() {
	printf("%.3f", FUNC(2));
	return 0;
}

float FUNC(int x ) {
	float tmp = x / 3.0 ;
	return tmp;
}

//2
void funk (void);

int main (void) {
	funk();	//() если void - то в скобках именно пусто быть должно. Даже void в скобках быть не	должен.
	return 0;
}

void funk(void){
	printf("HELLO\n");
	return; // хотя можно и не писать return здесь...
}

//3
int AAA(int);
int BBB(int);

int AAA(int aaa){
	int a ;
	a=BBB(aaa);
	return a;
}

int BBB(int aaa){
	int y;	
	y = aaa * 1000; 
    return y;
}

int main(){
	int ZZZ;
  	scanf ("%d", &ZZZ );
	printf("%d", AAA(ZZZ) );
	return 0;
}


Вызов по значению - вызываемой функции передаётся копия значения аргумента.
	Изменения с копией не отражаются на значении исходной переменной в вызывающей функции.
Вызов по ссылке - вызывающая функция позволяет вызываемой функции изменять значение исходной переменной.
В С все вызовы передают аргументы по значению. При этом есть методы имитации передачи по ссылке используя операцию взятия адреса 
	и косвенные операции.
Массивы автоматически передаются посредством имитации по ссылке. 

  
//область действия 
Стр. 209 и 211.
4 области: файла (test.c) , блока ( {} ), функции ( int funk(int y) ), прототипа ( int funk(int) ). 
   	
//классы памяти
Насчёт переменных непонятки... 
Переменная, которая известна только внутри функции, в которой она определена, называется
	локальной.
Переменная, объявленная вне любого блока или функции, является глобальной переменной.

Автоматический период хранения:
Существуют, пока блок активен, уничтожаются после выхода из блока.
auto float x; - слово auto используется редко, т.к. локальные переменные (в блоке или списке параметров функции)
	имеют auto по умолчанию. Auto экономит место в памяти.
register int counter = 1; - рекомендует компилятору поместить в регистр.

Статический период хранения:
Существуют с того момента, когда программа начинает выполнятся
extern - глобальные переменные	
static - локальные переменные
Дейтл, стр.211

Если своими словами попытаться.
	Область действия зависит одновременно и от самого кода (где находится идентификатор) и от периода хранения (класса памяти).
	Например, у переменной, написаной вне блоков или функций, будет область действия файла, но auto класс памяти. 
	А можно указать static и тогда у переменной будет область действия файла, но класс памяти уже static.
	Может быть переменная объявленная в блоке функции (локальная получается), но класс памяти, например, static.

Нюанс с объявлением переменных в for.
	В стандарте С99 добавили возможность инициализации и объявления переменной внутри цикла for. 
	Это несколько ломает привычную область действия переменных. Вроде как - область действия блока, а вроде как
	for превращается в отдельный блок.

#include <stdio.h>
int main(void){
	int i = 10;

	for(int i = 0, i <=2, i++ ){
		printf("%d\n", i);
	}
	
	printf("%d\n", i);
	return 0;
}
0
1
2
10

#include <stdio.h>
int main(void){
	int i = 10;

	for(i = 0; i <=2; i++ ){
		printf("%d\n", i);
	}
	
	printf("%d\n", i);
	return 0;
}
0
1
2
3

//рекурсия
Всё, что можно написать рекурсией - можно написать и итерацией. Нужно выбирать подход в зависимости от обстоятельств. Рекурсия требует
	больше ресурсов. 

int FUNC(int);

int main(void){
	int number;
	scanf("%d", &number);
	printf("%d!=%d\n", number, FUNC(number) );
	
}

int FUNC(int x){
	if(x <= 1){
		return 1;
	}
	else{
		return( x*FUNC(x-1) );
	}	

}

//массивы
printf("%p\n", &A ); - вывести адрес переменной в 16-ой форме. & - взятие адреса.
Scanf не требует & для массивов и строк (а строка это и есть массив).

Массив с 12 ячейками int с нулями: 
int A[12] = {0}; - по умолчанию в ячейках будут нули. 
Важно инициализировать хотя бы одну ячейку {0}, чтобы в остальных конкретно
появились нули. При этом {1} не поместит единицы во все ячейки.

или
int M[3] = {1, 2, 3};
или 
int M[] = {1, 2, 3}; - размер массива равен числу перечисленных значений

В массивах могут содержаться данные любого типа. 

Строка типа "hello" является массивом символов.
printf("%s\n", "lalala"); - массив как литерал
char string[] = "first"; - массив из 6 элементов где \0 символ подставляется
автоматически. Равносильно:
char string[] = { 'f', 'i', 'r', 's', 't', '\0' };
Так же, в char массивах [] необязательны.

Ввод строки в массив:
char string1[4];
scanf("%s", string1);
printf("%s\n", string1);

Вывод посимвольно:
int main(){
	char string1[100];
	scanf("%s", string1);//    вместо \0 может быть всё что угодно.
	for (int i = 0; string1[i] != '\0'; ++i){
		printf("%c\n", string1[i]);
	}
return 0;
}

Инкремент-постинкремент в массивах:
frq[i]=10
frq[i]=frq[i]+1
Равносильно
frq[i]=10
++frq[1]
Или
frq[1]++

static int A[3]; - массив не будет всякий раз создаваться при вызове функции и
уничтожаться после выхода из неё. Это уменьшает время работы.
