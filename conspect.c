Contents:
1. GCC
2. SUBLIME
3. Сompile
4. Conspectus

1. GCC//////////////////////////////////////////////////////////////////////////////
 
Настройка переменных сред для возможности ввода gcc без полного пути:
Переменные среды, создать PATH с значением D:\GDrive\books\C\MinGW\bin\

Настройка директории по-умолчанию при запуске консоли:
[HKEY_CURRENT_USER\Software\Microsoft\Command Processor] "Autorun"="cd /d D:\GDrive\books\С\MinGW\CUBEC" 
/d нужна при смене диска

Директории gcc:
MinGW\libexec\mingw-get\guimain.exe - update and setup
MinGW\bin\gcc.exe

2. SUBLIME///////////////////////////////////////////////////////////////////////

"fallback_encoding": "Cyrillic (Windows 1251)",
"auto_complete" : false,
"tab_completion" : false,
"update_check": false,

keyBinding:
{ "keys": ["f5"], "command": "save" },

Ctr + K + B скрыть панель слева
-
ctrl+[ - сдвинуть влево
ctrl+] - сдвинуть вправо

3. Сompile/////////////////////////////////////////////////////////////////////////////

Экранирование символов — механизм, имеющийся в текстовых языках и протоколах. 
Он служит, чтобы символы, которые считаются служебными и имеют особое значение, 
	этого значения лишить и объявить «просто символами». 
Нам нужно двойное экранирование: для ОС (строка с пробелами закавычивается) и для Си (перед кавычкой слэш).

system("gcc \"C:/Folder/My Folder/example.c\" ");
Точно так же экранируется и обратный слэш, если вдруг потребуется.
system("gcc \"C:\\Folder\\My Folder\\example.c\"" );

cd D:\books
gcc C:\Cex\test.c -o C:\Cex\test.exe

-c Compile or assemble the source files, but do not link
-S Stop after the stage of compilation proper; do not assemble. 

Исходник > препроцессор (что-то делает с .h) > компилятор (преобразует именно в машинный код) > компоновщик (линкер, линковщик)
В асме сначала идёт исходник, он трансилруется ассемблером в объектный код, замет линкуется линкером. 

4. Conspectus//////////////////////////////////////////////////////////////////


1. define/////////////////////////////////////////////////////////////////////
	
Умеют много чего, не путать с функцией, это именно символьные замены.

#include <stdio.h>
#define MASK(x) x&0xFF

int main(){
	printf("%d\n", MASK(4095)	 ); //n - ESC код, работают с функцией printf.
	//Равносильно такому написанию:
	printf("%d\n", 4095 & 0xFF	 );
	return 0;
}
4095	1111 1111 1111
0xFF	0000 1111 1111
AND=	0000 1111 1111

2. main - главная функция (в win нужно указывать тип возвращаемых int данных). ////////////

int main(){
	return 0; //return 0 - показывает успешное завершение, пиши это.
}

int maim(){
	int integer1;
	scanf ("%d", &integer1); 
}
Объявления должны располагаться после первой левой скобки и перед первым исполняемым оператором.

Идентификатор - последовательность символов (букв, цифр, _), это имя для переменных, типов, фукнций, меток.
"Имя идентификатора для функции - main, printf ; integer1 - идентификатор целой переменной"
Имя до 31 символа, учитываются строчные и заглавные буквы.

%d - спецификация преобразования, показывает, что данные должны быть целым числом.
&d - операция взятия адреса следующей за ним переменной. Сообщает сканфу ячейку памяти, 
	в которой хранится переменная integer1. Компьютер будет хранить 
	величину для integer1 в этой ячейке. Подробнее расмотрено в главе про указатели.

Явные и неявные преобразования.////////////////////////////////////////////////////////////

int main(){
	int A = 3; 
	int B = 2;
	float C = 2;
	printf("%.2f\n", A/B );				=1.00 - целое на целое отбросит дробную часть.
	printf("%.2f\n", A/C) ;				=1.50 - выполнит неявное преобразование целого B в float (создаст копию).
	printf("%.2f\n", (float) A/B );	=1.50	-выполнит явное преобразование A в float, что возведёт B до float.
}
3/2*3.14=3.14 , потому что 3/2 будет равно 1.

3. if/////////////////////////////////////////////////////////////////////////////////////

int main(){	
	int A;
	scanf ("%d", &A);
	
	if (A >= 2){
		printf(">=2\n");
	}

	if (A < 2){
		printf("<2\n");
	}
}

if (/* condition */)
	printf("AAA");
else if (/* condition */)
	printf("BBB");
else if (/* condition */)
	printf("CCC");

дополнение к if:
printf("%s\n", grade >= 60 ? "Passed" : "Failed" );
grade >= 60 ? printf("Passed") : printf("Failed" );

rvalue lvalue
int  day = 10, a;
day == 10 ? a = 1 : a = 0 ;	
printf("%d\n", a);
Так работать не будет, потому что нарушается принцип. ???

4. while////////////////////////////////////////////////////////////////////////////////

while (stud < 10){
	printf("AAA");
	stud = stud + 1;
}

5. операции присваивания, пре/пост, инкремента/декремента (стр.113)/////////////////////

c = c + 3;
равносильно
c += 3; - но так быстрее.
	
++a; // преинкремент, увеличивает на 1, использует новое значение.
a++; // постинкремент, использует значение, потом увеличивает на 1.  
a += 1 равносильно a = a + 1

a = 5;
printf("%d\n", ++a);		=6
printf("%d\n", a	);		=6	
a = 5;
printf("%d\n", a++);		=5
printf("%d\n", a	);		=6

6. while со счетчиком/////////////////////////////////////////////////////////////////////

int counter = 0;
while (++counter <= 2)
	printf("%d\n", counter);
1
2

int counter = 0;
while (counter++ <= 2)
	printf("%d\n", counter);
1
2
3

7. for////////////////////////////////////////////////////////////////////////////////////

int main(){
	for (int i = 0; i <= 2; i++){		//постинкремент выглядит естественнее, а прединкремент был бы эквивалентен.
		printf("%d\n", i );
	}
	return 0;
}
В стандарте С99 добавили возможность инициализации и объявления переменной внутри цикла for. 
	Смотри раздел про классы памяти.

8. switch/////////////////////////////////////////////////////////////////////////////////

int main(){
	int gon = 0;
	scanf ("%d", &gon);
	switch (gon) {
		case 1 : case 2 : // если gon = 1 или gon = 2.
			printf("1or2");
			break;
		case 5 : // если равен 5.
			printf("5");
			break;
		case '\n' : case '': // игнор символа переноса и пробела, если работа с символами.
			break;
		default : // все остальные случаи.
			printf("other");
			break;
	}
	return 0;
}	

9. do/while///////////////////////////////////////////////////////////////////////////////

int main(){
	int counter = 1;
	do {
		printf("%d\n", counter);
	}	while ( ++counter <= 10);
	return 0;
}

10. break/continue///////////////////////////////////////////////////////////////////////

int main(){
	int  x;
	for (x = 1; x <= 10; x++){
		if(x == 5)
			break; // break досрочно выводит из цикла, есть и другие структурные способы это сделать.
		printf("%d ", x );
	}
	printf("lalala %d\n", x);
	return 0;
}

int main(){
	int  x;
	for (x = 1; x <= 10; x++){
		if(x == 5)
			continue; // continue пропускает оставшийся код в цикле, если х == 5.
		printf("%d ", x );
	}
	printf("lalala %d\n", x);
	return 0;
}

11. логические////////////////////////////////////////////////////////////////////////////

int main(){
	int  x, A, B;
	scanf("%d%d%d", &x, &A, &B);

	if ( !(x == 2) )	
		printf("!(%d==2)\n", x);
	
	if ( A == 1 && B >= 10)		//Слева от && стараться ставить более вероятное условие, чтобы раньше перестать считать. 
		printf("Ab");
	return 0;
}
	
11.2. Побитовые операции.///////////////////////////////////////////////////////////////////

PORTX |= (1 << 2); - это сокращенная запись PORTX = PORTX | (1 << 2);
PORTX &= ~(1 << 2); - это сокращенная запись PORTX = PORTX & ~(1 << 2);

<< - побитовый сдвиг, сдвигает биты на 2 влево у числа 1.
	Получается 4, то есть (1 << 2) == 4.
~ - побитовое НЕ,  инвертирует биты.
| - побитовое ИЛИ.
	PORTX =  PORTX | 4; устанавливает 2-й бит числа PORTX в единицу.
& - И. 
	PORTX & 4 "извлекает" 2-й бит из числа (то есть PORTX & 4 == 0 когда 2-й бит равен 0 и PORTX & 4 != 0 когда 2-й бит равен 1)

12. функции////////////////////////////////////////////////////////////////////////////////

Любая функция должна быть объявлена перед тем, как будет использована, иначе будут ошибки. 

тип_возвращаемых_значений ИМЯ (тип_принимаемых_значений/список_параметров)
float FUNC(int, double);			//прототип
float FUNC(int x, double y) {}	//тело функции
Прототип соответствует списку параметров. Если прототип не указать - компилятор сам создаст кое-как прототип.
Прототип заставляет компилятор преобразовывать тип данных (int>float, etc). Имена лучше делать разными. 

float FUNC(int);
int main(){
	printf("%.3f", FUNC(3));
	return 0;
}
float FUNC(int x){
	float tmp = x / 2.0 ;
	return tmp;
}

void funk (void);
int main (void) {
	funk();	// если void - то в скобках должно быть пусто.
	return 0;
}
void funk(void){
	printf("HELLO\n");
	return;	// return здесь можно не писать .
}

int AAA(int);
int BBB(int);

int AAA(int aaa){
	int a ;
	a=BBB(aaa);
	return a;
}

int BBB(int aaa){
	int y;	
	y = aaa * 1000; 
	return y;
}

int main(){
	int ZZZ;
	scanf ("%d", &ZZZ );
	printf("%d", AAA(ZZZ) );
	return 0;
}

13. Заголовочные файлы .h//////////////////////////////////////////////////////////////////

Каждая библиотека имеет свой заголовочный файл, содержащий прототипы для всех функций
	данной библиотеки, а также определение типов данных и констант для этих функций.	
Можно создавать собственные заголовочные файлы. Подробнее в главе 13.

Директивы сообщают препроцессору о необходимости включения заголовочных файлов, 
	которые содержат много всего, в том числе - прототипы функций.

#include <stdio.h>	printf(), scanf() 
#include <stdlib.h>	system()
#include <math.h> 
#include <conio.h>	getchar()
#include <time.h>	time(NULL)
#include <unistd.h>	sleep()


14. Вызов функций///////////////////////////////////////////////////////////////

По значению - вызываемой функции передаётся копия значения аргумента.
	Изменения с копией не отражаются на значении исходной переменной в вызывающей функции.

По ссылке - вызывающая функция позволяет вызываемой функции изменять значение исходной переменной.

В С все вызовы передают аргументы по значению. 
	При этом есть методы имитации передачи по ссылке используя операцию взятия адреса 
	и косвенные операции.

Массивы автоматически передаются посредством имитации по ссылке. 
	Подробнее будет в главе 7.

15. Классы памяти/////////////////////////////////////////////////////////////////////////

Идентификаторы имеют атрибуты:
	имя, тип, значения, класс памяти, период хранения, область действия, тип компоновки (глава14).

Автоматический период хранения (существуют, пока блок активен, уничтожаются после выхода из блока) :
	auto float x; - слово auto используется редко, т.к. локальные переменные (в блоке или списке параметров функции)
	имеют auto по умолчанию. Auto экономит место в памяти.
	register int counter = 1; - рекомендует компилятору поместить в регистр.

Статический период хранения (существуют с того момента, когда программа начинает выполнятся) :
	extern - глобальные переменные	
	static - локальные переменные	

Области действия (Стр. 209 и 211.):
	файла			test.c , объявленные вне любой функции (в том числе вне main).
	блока			{} и параметры функций.
	прототипа	int funk(int) -причем, прототипы требуют только типы идентификаторов, имена им не нужны.
	функции		метки start: или case: в switch - единственные идентификаторы с областью действия функции.
	

Если своими словами:
	Область действия идентификатора/переменной зависит одновременно и от самого кода (где находится идентификатор) и от периода хранения (класса памяти).
	Например, переменная вне блоков или функций, будет область действия файла, но auto класс памяти. 
	Можно указать static и тогда у переменной будет область действия файла, но static класс памяти.
	Переменная может быть объявленна в блоке функции (локальная получается), но класс памяти, например, static.
	На стр.211 видно, что глобальные переменные вне main ведут себя как static. Причём, такая переменная видна функциям!
	Если внутри блока или функции переменная X не была инициализирована, то под переменной X будет 
		подразумеваться переменная X из предыдущей области, стр. 212 Дейтл. 
	
	Единственный пример static на 212 - функция, где значения инициализируется только при запуске программы. Зачем оно еще может быть нужно - хз.


	//Нюанс с объявлением переменных в for.
	В стандарте С99 добавили возможность инициализации и объявления переменной внутри цикла for. 
		Это несколько ломает привычную область действия переменных. Вроде как - область действия блока, а вроде как
		for превращается в отдельный блок.

	#include <stdio.h>
	int main(void){
		int i = 10;

		for(int i = 0, i <=2, i++ ){
			printf("%d\n", i);
		}
		
		printf("%d\n", i);
		return 0;
	}
	0
	1
	2
	10

	#include <stdio.h>
	int main(void){
		int i = 10;

		for(i = 0; i <=2; i++ ){
			printf("%d\n", i);
		}
		
		printf("%d\n", i);
		return 0;
	}
	0
	1
	2
	3

рекурсия.

	Всё, что можно написать рекурсией - можно написать и итерацией. Нужно выбирать подход в зависимости от обстоятельств. Рекурсия требует
		больше ресурсов. 

	int FUNC(int);

	int main(void){
		int number;
		scanf("%d", &number);
		printf("%d!=%d\n", number, FUNC(number) );
	}

	int FUNC(int x){
		if(x <= 1){
			return 1;
		}
		else{
			return( x*FUNC(x-1) );
		}	
	}

массивы.

	Массив с 3 ячейками int с нулями: 
		int MAZ[3] = {0}; - по умолчанию в ячейках будут нули. 
		Номера членов массива: 0, 1, 2.
		Важно инициализировать хотя бы одну ячейку {0}, чтобы в остальных конкретно
		появились нули. При этом {1} поместит единицу только в нулевую ячейку, а в остальные - нули.

	Можно перечислять переменные по отдельности:
		int MAZ1[3] = {1, 2, 3};

		int MAZ2[] = {1, 2, 3}; - размер массива равен числу перечисленных значений и будет "указан" автоматически. 
			Число перечисленных членов не должно превышать размер массива [], если записать его вручную.
	Имя массива - это адрес первой ячейки. Адрес первой ячейки - это имя массива.
	
	Инкремент-постинкремент в массивах:
		frq[i]=10
		frq[i]=frq[i]+1
		Равносильно:
		frq[i]=10
		++frq[1]
		Или:
		frq[1]++
	
	В массивах могут содержаться данные любого типа. 
		char string[20]; - создать символьный массив на 19 ячеек и ячейку \0 символ окончания строки. Судя по всему, без инициализации будет мусор.

		Строка типа "hello" является массивом символов:
		char string[] = "hello"; - здесь \0 нулевой символ окончания строки подставляется автоматически. Размер тоже подставляется автоматически.
		Или посимвольно:
		char string[] = { 'h', 'e', 'l', 'l', 'o', '\0' }; 
			
			printf и scanf не заботится размерах символьного массива. Что это значит - понятно наполовину, смотри дальше.
			

	Вывод строкой:
		char string[] = "ABCD"; - помнить нужно, что \0 тут будет подставлен автоматически.
		printf("%s\n", string); - символы выводятся до тех пор, пока не будет встречен \0.
		ABCD

		char string[] = {'A', 'B', '\0', 'C', 'D','E','\0'};
		printf("%s\n", string);
		AB

	Вывод посимвольно:
		printf("%p\n", &string[i] ); - & - взять адрес ячейки i и вывести его с помощью %p.	
		printf("%p\n", string ) равносильно printf("%p\n", &string[0] ) 

		char string[] = "ABCD";
		printf("%c\n", string[0]);
		A
		
		Можно сделать посимвольный вывод циклом с условием != '\0':
			char string[] = "ABCD";
				for (int i = 0; string[i] != '\0' ; ++i){
					printf("%c\n", string[i]);
				}	
			ABCD

	Ввод строки:
		char string[4];
		scanf("%s", string);  - scanf не требует & для массивов через %s, потому что имя массива является адресом его начала. 
			Так же - имя массива - это адрес первой ячейки.
			Так же scanf может записывать информацию за пределы массива, это нужно контроллировать.

		char string[] = {'A', 'B', '\0', 'C', 'D','E','\0'};
		scanf ("%s", string); - с %s scanf перезапишет всё и \0 его не остановит. Ну и дальше он спокойно выйдет за массив.
				
	Ввод посимвольно:
		Обязательно &, чтобы указать адрес ячейки в которую нужно положить значение!!!
		
		char string[SIZE];
		for (int i = 0; i < SIZE ; ++i){
			scanf("%c", &string[i]);
		}	

		for (int i = 0; i < SIZE ; ++i){
			printf("%c", string[i]);
		}	
	
	Статические массивы:
	
	static int A[3]; - массив не будет всякий раз создаваться при вызове функции и
		уничтожаться после выхода из неё. Это уменьшает время работы.
		Как именно оно там работает - непонятно.
		Статический массив по умолчанию инициализируется нулями.

		По сути, с практической точки зрения, static инициализирует
			(нули по умолчанию или иные перечесленные вручную значения) и при последующих
			вызовах не "обнуляет" их в исходные значения.
		В примере ниже эта фича используется внутри функции. 

		void A (void);
		void S (void);

		int main(){
		printf("first\n");	
			A();
			S();
		printf("second\n");
			A();
			S();
			return 0;
		}
		void A (void){
			int a[] = {1,2,3};
			printf("A\n");
			for (int i = 0; i < 3; ++i)	{
				printf("i=%d____p=%p____%d\n", i, &a[i], a[i] );
			}
			printf("A+5\n");
				for (int i = 0; i < 3; ++i)	{
				printf("i=%d____p=%p____%d\n", i, &a[i], a[i]+=5);
			}
		}
		void S(void){
			static int a[3];
			printf("S\n");
			for (int i = 0; i < 3; ++i)	{
				printf("i=%d____p=%p____%d\n", i, &a[i], a[i]);
			}
			printf("S+5\n");
			for (int i = 0; i < 3; ++i)	{
				printf("i=%d____p=%p____%d\n", i, &a[i], a[i]+=5);
			}
		}

		first
		A
		i=0____p=0028FF0C____1
		i=1____p=0028FF10____2
		i=2____p=0028FF14____3
		A+5
		i=0____p=0028FF0C____6
		i=1____p=0028FF10____7
		i=2____p=0028FF14____8
		S
		i=0____p=0040E020____0
		i=1____p=0040E024____0
		i=2____p=0040E028____0
		S+5
		i=0____p=0040E020____5
		i=1____p=0040E024____5
		i=2____p=0040E028____5
		second
		A
		i=0____p=0028FF0C____1
		i=1____p=0028FF10____2
		i=2____p=0028FF14____3
		A+5
		i=0____p=0028FF0C____6
		i=1____p=0028FF10____7
		i=2____p=0028FF14____8
		S
		i=0____p=0040E020____5
		i=1____p=0040E024____5
		i=2____p=0040E028____5
		S+5
		i=0____p=0040E020____10
		i=1____p=0040E024____10
		i=2____p=0040E028____10



передача массива в функции Стр. 264 Дейтл.

	int MAS[10];	- массив объявлен
	func(MAS, 10);	- оператор вызова функции передает массив MAS и его размер в функцию.
		
	Си передаёт массив в функцию путём имитации	передачи параметра по ссылке -
		вызываемые функции могут изменять значения элементов массива. 
		исходных массивах вызывающих функций. Ведь имя массива - это адрес первого элемента.
	Передача по значению требует копию, это неэффективно. Но такая возможно есть.
	Отдельные значения (скаляры) передются по значению.
		Чем имитация отличается от просто передачи по ссылке - пока хз.

	void func (int b[], int size)	
	Список параметров показывает, что функция ожидает приём массива целых чисел в параметре b 
		и числа элементов массива в параметре size. Размер массива не требуется. 
		А нах тогда size - хз.
		Поскольку массивы автоматически передаются путем имитации передачи по ссылке,
		то, когда функция использует имя массива b, она на самом деле ссылается на фактически
		существующий массив в вызывающей функции (массив MAS в предыдущем вызове).
		В главе 7 будут подробности. 
