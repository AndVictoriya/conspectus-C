Contents:
1. Setup and features GCC
2. Setup and features SUBLIME
3. About compile
4. Conspectus

1. Setup and features GCC
 
Настройка переменных сред для возможности ввода gcc без полного пути:
	компьютер свойства дополнительные параметры переменные среды создать PATH D:\GDrive\books\C\MinGW\bin\

Настройка директории по-умолчанию при запуске консоли:
	[HKEY_CURRENT_USER\Software\Microsoft\Command Processor] "Autorun"="cd /d D:\GDrive\books\С\MinGW\CUBEC" 
	/d нужна при смене диска

Директории gcc:
	MinGW\libexec\mingw-get\guimain.exe - update and setup
	MinGW\bin\gcc.exe

2. Setup and features SUBLIME
	"fallback_encoding": "Cyrillic (Windows 1251)",

	keyBinding:
	{ "keys": ["f5"], "command": "save" },

	Ctr + K + B скрыть панель слева

	ctrl+[ - сдвинуть влево
	ctrl+] - сдвинуть вправо

3. About compile

Заэкранировать кавыки:
	system("gcc \"C:/Folder/My Folder/example.c\"" );
	Точно так же экранируется и обратный слэш, если вдруг потребуется.
	system("gcc \"C:\\Folder\\My Folder\\example.c\"" );
	Экранирование символов — механизм, имеющийся в текстовых языках и протоколах. 
	Он служит, чтобы символы, которые считаются служебными и имеют особое значение, этого значения лишить и объявить «просто символами». 
	Нам нужно двойное экранирование: для ОС (строка с пробелами закавычивается) и для Си (перед кавычкой слэш).

cd D:\books
gcc C:\Cex\test.c -o C:\Cex\test.exe

-c Compile or assemble the source files, but do not link
-S Stop after the stage of compilation proper; do not assemble. 

исходник > препроцессор (что-то делает с .h) > компилятор (преобразует именно в машинный код) > компоновщик (линкер, линковщик)
В асме сначала идёт исходник, он трансилруется ассемблером в объектный код, замет линкуется линкером. 

4. Conspectus

Директивы нужны для препроцессора, сообщают ему о необходимости включения заголовочных файлов (stdio.h, например)
	которые содержат много всего, в том числе - прототипы функций.
	
	#include <stdio.h> printf(), scanf() 
	#include <stdlib.h> system()
	#include <math.h> 
	#include <conio.h> getchar()
	#include <time.h> time(NULL)
	#include <unistd.h> sleep()

define. 
	
	Умеют много чего, не путать с функцией, это именно символьные замены.
	#include <stdio.h>
	#define MASK(x) x&0xFF

	int main(){
		printf("%d\n", MASK(4095) );
		Равносильно такому написанию:
		printf("%d\n", 4095&0xFF );
		return 0;
	}
	4095 0xFFF 0000 1111 1111 1111


main - главная функция (в win нужно указывать тип возвращаемых (void, int) ею данных). 
	В случае, если функция возвращает ничего (void), указание возврата (return) можно не писать.
	В main return 0 означает конец  программы.

	int main(){
	}
	Или:
	int main(){
		return 0;
	}

	\n - ESC код, их много, работают с функцией printf.
	int maim(){
		int integer1;
		Объявление имен переменных и их типа данных, а также можно и значение указать.
		Имя до 31 символа, учитываются строчные и заглавные буквы.
		Объявления должны располагаться после первой левой скобки и  п е р е д  п е р в ы м  исполняемым оператором.
		int integer2 = 123;

		scanf ("%d", &integer1) 
		%d - показывает, что данные должны быть целым числом
		&d - знаком амперсанда задается операция взятия адреса следующей за ним переменной.
		Сообщает сканфу ячейку памяти, в которой хранится переменная integer1. Компьютер будет хранить 
			величину для integer1 в этой ячейке. Подробнее расмотрено в главе про указатели.
	}

Явные и неявные преобразования.

	int main(){
		int A = 5; 
		int B = 2;
		float C = 2;
		printf("%d\n", A/B );			-целое на целое отбросит дробную часть
		printf("%f\n", A/C) ;			-выполнит неявное преобразование целого B в float (создаст копию)
		printf("%f\n", (float) A/B );	-выполнит явное преобразование A в float, B тогда возведётся до float
	}
		Ибо первое преобразование int даст 1.
		3/2*3.14=3.14 

if.

	int main(){	
		int A;
		scanf ("%d", &A);
		
		if (A >= 2){
			printf(">=2\n");
		}

		if (A < 2){
			printf("<2\n");
		}

	}

	if (/* condition */)
		printf("AAA");
	else
		if (/* condition */)
			printf("BBB");
		else
			if ()
				printf("CCC");

	if (/* condition */)
		printf("AAA");
	else if (/* condition */)
		printf("BBB");
	else if (/* condition */)
		printf("CCC");

	дополнение к if:
	printf("%s\n", grade >= 60 ? "Passed" : "Failed" );
	grade >= 60 ? printf("Passed") : printf("Failed" );

while.

	while (stud < 10){
		printf("AAA");
		stud = stud + 1;
	}

операции присваивания.

	c = c + 3;
	равносильно
	c += 3; - но так быстрее.
		
	++a; // преинкремент, увеличивает на 1, использует новое значение.
	a++; // постинкремент, использует значение, потом увеличивает на 1.  
	a += 1 равносильно a = a + 1

	a = 5;
	printf("%d\n", ++a );
	printf("%d\n", a);
	a = 5;
	printf("%d\n", a++);
	printf("%d\n", a);

	даст:
	6
	6
	5
	6


	int counter = 0;
	while (++counter <= 2)
		printf("%d\n", counter);
	1
	2

	int counter = 0;
	while (counter++ <= 2)
		printf("%d\n", counter);
	1
	2
	3

for.

	В стандарте С99 добавили возможность инициализации и объявления переменной внутри цикла for. 
	Это несколько ломает привычную область действия переменных. Вроде как - область действия блока, а вроде как
	for превращается в отдельный блок. 
		Дополнительно смотри раздел про классы памяти.

	int main(){
		for (int i = 0; i <= 2; i++){
			printf("%d\n", i );
		}
		return 0;
	}

switch.

	int main(){
		int gon = 0;
		scanf ("%d", &gon);
		switch (gon) {
			case 1 : case 2 : // если gon = 1 или gon = 2
				printf("1or2");
				break;
			case 5 : // если равен 5
				printf("5");
				break;
			case '\n' : case '': // игнор символа переноса и пробела, если работа с символами
				break;
			default : // все остальные случаи
				printf("other");
				break;
		}
		return 0;
	}	

do/while.

	int main(){
		int counter = 1;
		do {
			printf("%d\n", counter);
		}	while ( ++counter <= 10);
		return 0;
	}

break/continue.

	int main(){
		int  x;
		for (x = 1; x <= 10; x++){
			if(x == 5)
				break; // break досрочно выводит из цикла, есть и другие структурные способы это сделать.
			printf("%d ", x );
		}
		printf("lalala %d\n", x);
		return 0;
	}

	int main(){
		int  x;
		for (x = 1; x <= 10; x++){
			if(x == 5)
				continue; // continue пропускает оставшийся код в цикле, если х == 5.
			printf("%d ", x );
		}
		printf("lalala %d\n", x);
		return 0;
	}

логические.

	int main(){
		int  x;

		scanf("%d", &x);

		if ( !(x == 2) )	{
			printf("!(%d==2)\n", x);
		}		
		return 0;
	}


	PORTX |= (1 << 2); - это сокращенная запись PORTX = PORTX | (1 << 2);
	PORTX &= ~(1 << 2); - это сокращенная запись PORTX = PORTX & ~(1 << 2);

	<< - побитовый сдвиг, сдвигает биты на 2 влево у числа 1.
		Получается 4, то есть (1 << 2) == 4.
	~ - побитовое НЕ,  инвертирует биты.
	| - побитовое ИЛИ.
		PORTX =  PORTX | 4; устанавливает 2-й бит числа PORTX в единицу.
	& - И. 
		PORTX & 4 "извлекает" 2-й бит из числа (то есть PORTX & 4 == 0 когда 2-й бит равен 0 и PORTX & 4 != 0 когда 2-й бит равен 1)

функции.

	Любая функция должна быть объявлена перед тем, как будет использована, иначе будут ошибки. Хотя, если написать тело функции до main... 
		Стр180 Дейтла.
	Прототип соответствует списку параметров. Если прототип не указать - компилятор сам создаст кое-как прототип и будет плохо.
	Имена лучше делать разными. 

	Если не указать тип возвращаемых - то по-умолчанию будет int.
	Если не указать тип принимаемых - то ????? скорее всего будет void, может быть тогда может принимать любое количество параметров...
		Лучше конкретно указывать void. А вот в main это непринципиально, вероятно.

	тип возвращаемых ИМЯ (тип принимаемых значений по порядку, оно же список параметров)

	float FUNC(int, double); -прототип
	float FUNC(int x, double y) { -тело функции
	}

	//1
	float FUNC(int);
		
	int main() {
		printf("%.3f", FUNC(2));
		return 0;
	}

	float FUNC(int x ) {
		float tmp = x / 3.0 ;
		return tmp;
	}

	//2
	void funk (void);

	int main (void) {
		funk();	- () если void - то в скобках именно пусто быть должно. Даже void в скобках быть не	должен.
		return 0;
	}

	void funk(void){
		printf("HELLO\n");
		return; // хотя можно и не писать return здесь...
	}

	//3
	int AAA(int);
	int BBB(int);

	int AAA(int aaa){
		int a ;
		a=BBB(aaa);
		return a;
	}

	int BBB(int aaa){
		int y;	
		y = aaa * 1000; 
		return y;
	}

	int main(){
		int ZZZ;
		scanf ("%d", &ZZZ );
		printf("%d", AAA(ZZZ) );
		return 0;
	}


Вызов по значению - вызываемой функции передаётся копия значения аргумента.
	Изменения с копией не отражаются на значении исходной переменной в вызывающей функции.

Вызов по ссылке - вызывающая функция позволяет вызываемой функции изменять значение исходной переменной.

В С все вызовы передают аргументы по значению. При этом есть методы имитации передачи по ссылке используя операцию взятия адреса 
	и косвенные операции.

Массивы автоматически передаются посредством имитации по ссылке. 
	Что именно всё это значит - непонятно.
  
область действия.
	Стр. 209 и 211.
	4 области действия:
		файла		test.c
		блока		{}
		функции		int funk(int y)
		прототипа	int funk(int)
   	
классы памяти.

	Насчёт переменных непонятно...
	Переменная, которая известна только внутри функции, в которой она определена, называется локальной.
	Переменная, объявленная вне любого блока или функции, является глобальной переменной.

	Автоматический период хранения:
		Существуют, пока блок активен, уничтожаются после выхода из блока.
		auto float x; - слово auto используется редко, т.к. локальные переменные (в блоке или списке параметров функции)
			имеют auto по умолчанию. Auto экономит место в памяти.
		register int counter = 1; - рекомендует компилятору поместить в регистр.

	Статический период хранения:
		Существуют с того момента, когда программа начинает выполнятся
		extern - глобальные переменные	
		static - локальные переменные
	Дейтл, стр.211

	Если своими словами:
		Область действия зависит одновременно и от самого кода (где находится идентификатор) и от периода хранения (класса памяти).
		Например, у переменной, написаной вне блоков или функций, будет область действия файла, но auto класс памяти. 
		А можно указать static и тогда у переменной будет область действия файла, но класс памяти уже static.
		Может быть переменная объявленная в блоке функции (локальная получается), но класс памяти, например, static.
	На стр.211 видно, что глобальные переменные вне main ведут себя как static. Причём, такая переменная видна функциям.
		И последний момент - если внутри блока или функции переменная X не была инициализирована, то под переменной X будет 
			подразумеваться переменная X из другой области, стр. 212 Дейтл. 

	//Нюанс с объявлением переменных в for.
	В стандарте С99 добавили возможность инициализации и объявления переменной внутри цикла for. 
		Это несколько ломает привычную область действия переменных. Вроде как - область действия блока, а вроде как
		for превращается в отдельный блок.

	#include <stdio.h>
	int main(void){
		int i = 10;

		for(int i = 0, i <=2, i++ ){
			printf("%d\n", i);
		}
		
		printf("%d\n", i);
		return 0;
	}
	0
	1
	2
	10

	#include <stdio.h>
	int main(void){
		int i = 10;

		for(i = 0; i <=2; i++ ){
			printf("%d\n", i);
		}
		
		printf("%d\n", i);
		return 0;
	}
	0
	1
	2
	3

рекурсия.

	Всё, что можно написать рекурсией - можно написать и итерацией. Нужно выбирать подход в зависимости от обстоятельств. Рекурсия требует
		больше ресурсов. 

	int FUNC(int);

	int main(void){
		int number;
		scanf("%d", &number);
		printf("%d!=%d\n", number, FUNC(number) );
	}

	int FUNC(int x){
		if(x <= 1){
			return 1;
		}
		else{
			return( x*FUNC(x-1) );
		}	
	}

массивы.

	Массив с 3 ячейками int с нулями: 
		int MAZ[3] = {0}; - по умолчанию в ячейках будут нули. 
		Номера членов массива: 0, 1, 2.
		Важно инициализировать хотя бы одну ячейку {0}, чтобы в остальных конкретно
		появились нули. При этом {1} поместит единицу только в нулевую ячейку, а в остальные - нули.

	Можно перечислять переменные по отдельности:
		int MAZ1[3] = {1, 2, 3};

		int MAZ2[] = {1, 2, 3}; - размер массива равен числу перечисленных значений и будет "указан" автоматически. 
			Число перечисленных членов не должно превышать размер массива [], если записать его вручную.

	В массивах могут содержаться данные любого типа. 
		char string[20]; - создать символьный массив на 19 ячеек и ячейку \0 символ окончания строки. Судя по всему, без инициализации будет мусор.

		Строка типа "hello" является массивом символов:
		char string[] = "hello"; - здесь \0 нулевой символ окончания строки подставляется автоматически. Размер тоже подставляется автоматически.
		Или посимвольно:
		char string[] = { 'h', 'e', 'l', 'l', 'o', '\0' }; 
			
			printf и scanf не заботится размерах символьного массива. Что это значит - понятно наполовину, смотри дальше.
			

	Вывод строкой:
		char string[] = "ABCD"; - помнить нужно, что \0 тут будет подставлен автоматически.
		printf("%s\n", string); - символы выводятся до тех пор, пока не будет встречен \0.
		ABCD

		char string[] = {'A', 'B', '\0', 'C', 'D','E','\0'};
		printf("%s\n", string);
		AB

	Вывод посимвольно:
		printf("%p\n", &string[i] ); - & - взять адрес ячейки i и вывести его с помощью %p.	
		printf("%p\n", string ) равносильно printf("%p\n", &string[0] ) 

		char string[] = "ABCD";
		printf("%c\n", string[0]);
		A
		
		Можно сделать посимвольный вывод циклом с условием != '\0':
			char string[] = "ABCD";
				for (int i = 0; string[i] != '\0' ; ++i){
					printf("%c\n", string[i]);
				}	
			ABCD

	Ввод строки:
		char string[4];
		scanf("%s", string);  - scanf не требует & для массивов через %s, потому что имя массива является адресом его начала. 
			Так же - имя массива - это адрес первой ячейки.
			Так же scanf может записывать информацию за пределы массива, это нужно контроллировать.

		char string[] = {'A', 'B', '\0', 'C', 'D','E','\0'};
		scanf ("%s", string); - с %s scanf перезапишет всё и \0 его не остановит. Ну и дальше он спокойно выйдет за массив.
				
	Ввод посимвольно:
		Обязательно &, чтобы указать адрес ячейки в которую нужно положить значение!!!
		
		char string[SIZE];
		for (int i = 0; i < SIZE ; ++i){
			scanf("%c", &string[i]);
		}	

		for (int i = 0; i < SIZE ; ++i){
			printf("%c", string[i]);
		}	

	Инкремент-постинкремент в массивах:
		frq[i]=10
		frq[i]=frq[i]+1
	Равносильно:
		frq[i]=10
		++frq[1]
		Или:
		frq[1]++

	static int A[3]; - массив не будет всякий раз создаваться при вызове функции и
		уничтожаться после выхода из неё. Это уменьшает время работы.
		Как именно оно там работает - непонятно.
		Статический массив по умолчанию инициализируется нулями.

		void staticMAS (void);
		void autoMAS (void);

		int main(){
			staticMAS();
			autoMAS();
			return 0;
		}
		Ну и если что-то менять со статиком, то изменения будут сохраняться.
		void staticMAS(void){
			static int a[3];
			for (int i = 0; i < 3; ++i)	{
				printf("%d\n", a[i]);
			}
		}
		void autoMAS (void){
			int a[] = {1,2,3};
			for (int i = 0; i < 3; ++i)	{
				printf("%d\n", a[i]);
			}
		}


передача массива в функции Стр. 264 Дейтл.

	int MAS[10];	- массив объявлен
	func(MAS, 10);	- оператор вызова функции передает массив MAS и его размер в функцию.
		
	Си передаёт массив в функцию путём имитации	передачи параметра по ссылке -
		вызываемые функции могут изменять значения элементов в 
		исходных массивах вызывающих функций. Ведь имя массива - это адрес первого элемента.
	Передача по значение требует копию, это неэффективно. Но такая возможно есть.
	Отдельные значения (скаляры) передются по значению.

	void func (int b[], int size)	
	Список параметров показывает, что функция ожидает приём массива целых чисел в параметре b 
		и числа элементов массива в параметре size. Размер массива не требуется. 
		Поскольку массивы автоматически передаются путем имитации передачи по ссылке,
		то, когда функция использует имя массива b, она на самом деле ссылается на фактически
		существующий массив в вызывающей функции (массив MAS в предыдущем вызове).
		В главе 7 будут подробности. 
